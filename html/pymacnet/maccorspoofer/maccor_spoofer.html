<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pymacnet.maccorspoofer.maccor_spoofer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pymacnet.maccorspoofer.maccor_spoofer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import socket
import json
import threading
import pymacnet.messages

class MaccorSpoofer:

    __client_connect_timeout_s = 1
    __stop_servers_lock = threading.Lock()
    __stop_servers = False

    def __init__(self, config: dict):
        &#34;&#34;&#34;
        Class to mimic behavior of Maccor cycler MacNet control server. The class is currently dumb 
        and just sends back basic response messages without any notion of channel status or readings. 
        It could be expanded in future. 
        -------
        Parameters
        ----------
        config : dict
            A configuration dictionary containing the server ip address and ports to use. The
            fields to include are as follows:

            `server_ip`: The server IP address to host from. Most often &#39;localhost&#39; for testing.

            `json_port`: The port to use for the JSON server.

            `tcp_port`: the port to use for the TCP server.
        &#34;&#34;&#34;
        self.config = config

        json_server_config = {&#39;ip&#39;:config[&#39;server_ip&#39;],&#39;port&#39;:config[&#39;json_port&#39;]}
        self.__json_server_thread = threading.Thread( target=self.__server_loop, 
                                                        args=( json_server_config, _JsonWorker,), 
                                                        daemon=True)

        tcp_server_config = {&#39;ip&#39;:config[&#39;server_ip&#39;],&#39;port&#39;:config[&#39;tcp_port&#39;]}
        self.__tcp_server_thread = threading.Thread( target=self.__server_loop,
                                                         args=( tcp_server_config, _TcpWorker,), 
                                                        daemon=True)

    def start(self):
        &#34;&#34;&#34;
        Starts the server loops.
        &#34;&#34;&#34;
        self.__json_server_thread.start()       
        self.__tcp_server_thread.start()

    def __server_loop( self, sock_config : dict, Worker):  
        &#34;&#34;&#34;
        Creates a server and forever loop to service client socket requests.
        ----------
        sock_cofig : dict
            A configuration for the socket containing the IP and port number.
        Worker : _SocketWorker
            A reference to the worker class that will service individual client connections.
        &#34;&#34;&#34;       
        # List that will hold all the workers to service client connections.
        client_workers = [] 

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind((sock_config[&#34;ip&#34;], sock_config[&#34;port&#34;]))
        sock.settimeout(self.__client_connect_timeout_s)
        sock.listen()
        
        while True:
            try: 
                client_connection, client_address = sock.accept()
                client_workers.append(Worker(client_connection))
            except socket.timeout:
                with self.__stop_servers_lock:
                    # If stop commmand is issued then kill all workers.
                    if self.__stop_servers:
                        for worker in client_workers:
                            if worker.is_alive():
                                worker.kill_worker()
                        break
                # Remove any workers that made have died from disconnecting clients.
                client_workers[:] = [worker for worker in client_workers if worker.is_alive()]                         

    def stop(self):
        &#34;&#34;&#34;
        Stop the server loops.
        &#34;&#34;&#34;
        with self.__stop_servers_lock:
            self.__stop_servers = True
        self.__json_server_thread.join()
        self.__tcp_server_thread.join()

    def __del__(self):
        self.stop()

class _SocketWorker:
    &#39;&#39;&#39;
    Generic worker class that will respond to client socket requests. 
    Default setup as an echo server. Child classes should overwrite the 
    the `_process_client_msg()` method with their own responses.
    &#39;&#39;&#39;
    __receive_msg_timeout_s = 1
    __msg_buffer_size_bytes = 1024
    __stop_lock = threading.Lock()
    __stop = False

    def __init__(self, s: socket.socket):
        &#34;&#34;&#34;
        Creates the thread to service client requests.
        ----------
        s : socket.socket
            Socket connection to client.
        &#34;&#34;&#34;
        self.stop = False
        self.__client_thread = threading.Thread( target=self.___service_loop, args=(s,), daemon=True)
        self.__client_thread.start()
    
    def ___service_loop(self, s: socket.socket):
        &#34;&#34;&#34;
        Forever loop to service client requests. Wait to receive a message. If no messages is 
        received before the timeout then check to see if stop command has been issued. Loop is 
        also broken if client breaks conenction by sending b&#39;&#39;. 
        ----------
        s : socket.socket
            Socket connection to client.
        &#34;&#34;&#34;
        s.settimeout(self.__receive_msg_timeout_s)

        while True:
            try:
                rx_msg = s.recv(self.__msg_buffer_size_bytes)
                if not rx_msg:
                    break
                tx_msg = self._process_client_msg(rx_msg)
                s.sendall(tx_msg)
            except socket.timeout:
                with self.__stop_lock:
                    if self.__stop:    
                        break
        s.close()

    def _process_client_msg(self, rx_msg):
        &#34;&#34;&#34;
        Takes the incoming client message and generates a response. 
        ----------
        rx_msg : PyBytesObject
            The client message received.
        Returns
        -------
        tx_msg : PyBytesObject
            The client response.
        &#34;&#34;&#34;
        return rx_msg

    def is_alive(self):
        &#34;&#34;&#34;
        Method to call to see if the client service thread is still running.
        Returns
        -------
        running : bool
            True of False based on whether or not the client thread is running.
        &#34;&#34;&#34;
        return self.__client_thread.is_alive()

    def kill_worker(self):
        &#39;&#39;&#39;
        Method to stop client service loop.
        &#39;&#39;&#39;
        if self.__client_thread.is_alive():
            with self.__stop_lock:
                self.__stop = True
            self.__client_thread.join()

class _JsonWorker(_SocketWorker):
    &#39;&#39;&#39;
    Class to handle requests from MacNet JSON socket clients.
    &#39;&#39;&#39;

    def _process_client_msg(self, rx_msg):
        &#34;&#34;&#34;
        Takes the incoming JSON client message and generates a response. 
        ----------
        rx_msg : PyBytesObject
            The client message received.
        Returns
        -------
        tx_msg : PyBytesObject
            The client response.
        &#34;&#34;&#34;

        rx_msg = json.loads(rx_msg)
        if (pymacnet.messages.tx_read_status_msg[&#39;params&#39;][&#39;FClass&#39;] == rx_msg[&#39;params&#39;][&#39;FClass&#39;] and 
                pymacnet.messages.tx_read_status_msg[&#39;params&#39;][&#39;FNum&#39;] == rx_msg[&#39;params&#39;][&#39;FNum&#39;]):
            tx_msg = pymacnet.messages.rx_read_status_msg
            tx_msg[&#39;result&#39;][&#39;Chan&#39;] = rx_msg[&#39;params&#39;][&#39;Chan&#39;]
        elif (pymacnet.messages.tx_read_aux_msg[&#39;params&#39;][&#39;FClass&#39;] == rx_msg[&#39;params&#39;][&#39;FClass&#39;] and 
                pymacnet.messages.tx_read_aux_msg[&#39;params&#39;][&#39;FNum&#39;] == rx_msg[&#39;params&#39;][&#39;FNum&#39;]):
            tx_msg = pymacnet.messages.rx_read_aux_msg
            tx_msg[&#39;result&#39;][&#39;Chan&#39;] = rx_msg[&#39;params&#39;][&#39;Chan&#39;]
        elif (pymacnet.messages.tx_start_test_with_procedure_msg[&#39;params&#39;][&#39;FClass&#39;] == rx_msg[&#39;params&#39;][&#39;FClass&#39;] and 
                pymacnet.messages.tx_start_test_with_procedure_msg[&#39;params&#39;][&#39;FNum&#39;] == rx_msg[&#39;params&#39;][&#39;FNum&#39;]):
            tx_msg = pymacnet.messages.rx_start_test_with_procedure_msg
            tx_msg[&#39;result&#39;][&#39;Chan&#39;] = rx_msg[&#39;params&#39;][&#39;Chan&#39;]
        elif (pymacnet.messages.tx_set_variable_msg[&#39;params&#39;][&#39;FClass&#39;] == rx_msg[&#39;params&#39;][&#39;FClass&#39;] and 
                pymacnet.messages.tx_set_variable_msg[&#39;params&#39;][&#39;FNum&#39;] == rx_msg[&#39;params&#39;][&#39;FNum&#39;]):
            tx_msg = pymacnet.messages.rx_set_variable_msg
            tx_msg[&#39;result&#39;][&#39;Chan&#39;] = rx_msg[&#39;params&#39;][&#39;Chan&#39;]
        elif (pymacnet.messages.tx_start_test_with_direct_control_msg[&#39;params&#39;][&#39;FClass&#39;] == rx_msg[&#39;params&#39;][&#39;FClass&#39;] and 
                pymacnet.messages.tx_start_test_with_direct_control_msg[&#39;params&#39;][&#39;FNum&#39;] == rx_msg[&#39;params&#39;][&#39;FNum&#39;]):
            tx_msg = pymacnet.messages.rx_start_test_with_direct_control_msg
            tx_msg[&#39;result&#39;][&#39;Chan&#39;] = rx_msg[&#39;params&#39;][&#39;Chan&#39;]
        elif (pymacnet.messages.tx_set_direct_output_msg[&#39;params&#39;][&#39;FClass&#39;] == rx_msg[&#39;params&#39;][&#39;FClass&#39;] and 
                pymacnet.messages.tx_set_direct_output_msg[&#39;params&#39;][&#39;FNum&#39;] == rx_msg[&#39;params&#39;][&#39;FNum&#39;]):
            tx_msg = pymacnet.messages.rx_set_direct_output_msg
            tx_msg[&#39;result&#39;][&#39;Chan&#39;] = rx_msg[&#39;params&#39;][&#39;Chan&#39;]
        elif (pymacnet.messages.tx_reset_channel_msg[&#39;params&#39;][&#39;FClass&#39;] == rx_msg[&#39;params&#39;][&#39;FClass&#39;] and 
                pymacnet.messages.tx_reset_channel_msg[&#39;params&#39;][&#39;FNum&#39;] == rx_msg[&#39;params&#39;][&#39;FNum&#39;]):
            tx_msg = pymacnet.messages.rx_reset_channel_msg
            tx_msg[&#39;result&#39;][&#39;Chan&#39;] = rx_msg[&#39;params&#39;][&#39;Chan&#39;]
        elif (pymacnet.messages.tx_set_safety_limits_msg[&#39;params&#39;][&#39;FClass&#39;] == rx_msg[&#39;params&#39;][&#39;FClass&#39;] and 
                pymacnet.messages.tx_set_safety_limits_msg[&#39;params&#39;][&#39;FNum&#39;] == rx_msg[&#39;params&#39;][&#39;FNum&#39;]):
            tx_msg = pymacnet.messages.rx_set_safety_limits_msg
            tx_msg[&#39;result&#39;][&#39;Chan&#39;] = rx_msg[&#39;params&#39;][&#39;Chan&#39;]
            tx_msg[&#39;result&#39;][&#39;VSafeMax&#39;] = rx_msg[&#39;params&#39;][&#39;VSafeMax&#39;]
            tx_msg[&#39;result&#39;][&#39;VSafeMin&#39;] = rx_msg[&#39;params&#39;][&#39;VSafeMin&#39;]
            tx_msg[&#39;result&#39;][&#39;ISafeChg&#39;] = rx_msg[&#39;params&#39;][&#39;ISafeChg&#39;]
            tx_msg[&#39;result&#39;][&#39;ISafeDis&#39;] = rx_msg[&#39;params&#39;][&#39;ISafeDis&#39;]
            tx_msg[&#39;result&#39;][&#39;PBatSafeChg&#39;] = rx_msg[&#39;params&#39;][&#39;PBatSafeChg&#39;]
            tx_msg[&#39;result&#39;][&#39;PBatSafeDis&#39;] = rx_msg[&#39;params&#39;][&#39;PBatSafeDis&#39;]
        else:
            tx_msg = {&#39;err&#39;:1}

        tx_msg = json.dumps( tx_msg, indent = 4)
        tx_msg = tx_msg.encode(&#39;utf-8&#39;)

        return tx_msg

class _TcpWorker(_SocketWorker):
    &#39;&#39;&#39;
    Class to handle requests from TCP socket clients.
    Currently just implemented as an echo server.
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pymacnet.maccorspoofer.maccor_spoofer.MaccorSpoofer"><code class="flex name class">
<span>class <span class="ident">MaccorSpoofer</span></span>
<span>(</span><span>config:Â dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to mimic behavior of Maccor cycler MacNet control server. The class is currently dumb
and just sends back basic response messages without any notion of channel status or readings.
It could be expanded in future. </p>
<hr>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>A configuration dictionary containing the server ip address and ports to use. The
fields to include are as follows:</p>
<p><code>server_ip</code>: The server IP address to host from. Most often 'localhost' for testing.</p>
<p><code>json_port</code>: The port to use for the JSON server.</p>
<p><code>tcp_port</code>: the port to use for the TCP server.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MaccorSpoofer:

    __client_connect_timeout_s = 1
    __stop_servers_lock = threading.Lock()
    __stop_servers = False

    def __init__(self, config: dict):
        &#34;&#34;&#34;
        Class to mimic behavior of Maccor cycler MacNet control server. The class is currently dumb 
        and just sends back basic response messages without any notion of channel status or readings. 
        It could be expanded in future. 
        -------
        Parameters
        ----------
        config : dict
            A configuration dictionary containing the server ip address and ports to use. The
            fields to include are as follows:

            `server_ip`: The server IP address to host from. Most often &#39;localhost&#39; for testing.

            `json_port`: The port to use for the JSON server.

            `tcp_port`: the port to use for the TCP server.
        &#34;&#34;&#34;
        self.config = config

        json_server_config = {&#39;ip&#39;:config[&#39;server_ip&#39;],&#39;port&#39;:config[&#39;json_port&#39;]}
        self.__json_server_thread = threading.Thread( target=self.__server_loop, 
                                                        args=( json_server_config, _JsonWorker,), 
                                                        daemon=True)

        tcp_server_config = {&#39;ip&#39;:config[&#39;server_ip&#39;],&#39;port&#39;:config[&#39;tcp_port&#39;]}
        self.__tcp_server_thread = threading.Thread( target=self.__server_loop,
                                                         args=( tcp_server_config, _TcpWorker,), 
                                                        daemon=True)

    def start(self):
        &#34;&#34;&#34;
        Starts the server loops.
        &#34;&#34;&#34;
        self.__json_server_thread.start()       
        self.__tcp_server_thread.start()

    def __server_loop( self, sock_config : dict, Worker):  
        &#34;&#34;&#34;
        Creates a server and forever loop to service client socket requests.
        ----------
        sock_cofig : dict
            A configuration for the socket containing the IP and port number.
        Worker : _SocketWorker
            A reference to the worker class that will service individual client connections.
        &#34;&#34;&#34;       
        # List that will hold all the workers to service client connections.
        client_workers = [] 

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind((sock_config[&#34;ip&#34;], sock_config[&#34;port&#34;]))
        sock.settimeout(self.__client_connect_timeout_s)
        sock.listen()
        
        while True:
            try: 
                client_connection, client_address = sock.accept()
                client_workers.append(Worker(client_connection))
            except socket.timeout:
                with self.__stop_servers_lock:
                    # If stop commmand is issued then kill all workers.
                    if self.__stop_servers:
                        for worker in client_workers:
                            if worker.is_alive():
                                worker.kill_worker()
                        break
                # Remove any workers that made have died from disconnecting clients.
                client_workers[:] = [worker for worker in client_workers if worker.is_alive()]                         

    def stop(self):
        &#34;&#34;&#34;
        Stop the server loops.
        &#34;&#34;&#34;
        with self.__stop_servers_lock:
            self.__stop_servers = True
        self.__json_server_thread.join()
        self.__tcp_server_thread.join()

    def __del__(self):
        self.stop()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pymacnet.maccorspoofer.maccor_spoofer.MaccorSpoofer.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the server loops.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;
    Starts the server loops.
    &#34;&#34;&#34;
    self.__json_server_thread.start()       
    self.__tcp_server_thread.start()</code></pre>
</details>
</dd>
<dt id="pymacnet.maccorspoofer.maccor_spoofer.MaccorSpoofer.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the server loops.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#34;&#34;&#34;
    Stop the server loops.
    &#34;&#34;&#34;
    with self.__stop_servers_lock:
        self.__stop_servers = True
    self.__json_server_thread.join()
    self.__tcp_server_thread.join()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pymacnet.maccorspoofer" href="index.html">pymacnet.maccorspoofer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pymacnet.maccorspoofer.maccor_spoofer.MaccorSpoofer" href="#pymacnet.maccorspoofer.maccor_spoofer.MaccorSpoofer">MaccorSpoofer</a></code></h4>
<ul class="">
<li><code><a title="pymacnet.maccorspoofer.maccor_spoofer.MaccorSpoofer.start" href="#pymacnet.maccorspoofer.maccor_spoofer.MaccorSpoofer.start">start</a></code></li>
<li><code><a title="pymacnet.maccorspoofer.maccor_spoofer.MaccorSpoofer.stop" href="#pymacnet.maccorspoofer.maccor_spoofer.MaccorSpoofer.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>